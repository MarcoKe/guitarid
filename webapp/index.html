<html>
  <head>
    <style>
      .upload-container {
        width: 300px;
        height: 200px;
        border: 2px dashed #ccc;
        border-radius: 10px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        font-family: Arial, sans-serif;
        color: #888;
        transition: border-color 0.3s;
      }

      .upload-container:hover {
        border-color: #666;
      }

      .hidden-input {
        display: none;
      }

      img {
        max-width: 100%;
        max-height: 100%;
      }

      .output {
        margin-top: 20px;
        font-family: Arial, sans-serif;
        color: #333;
      }
    </style>
  </head>

  <body>
    <div class="upload-container" id="upload-container" onclick="document.getElementById('file-input').click();">
      Click to upload guitar image
    </div>
    <input type="file" id="file-input" class="hidden-input" accept="image/*" onchange="handleImageUpload(event)">
    <div class="output" id="output"></div>

    <!-- Load ONNX.js -->
    <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
    <script>
      let session;

      const classNames = ['Ibanez RG370DX', 'fender player stratocaster'];
      const modelOutputName = '467';


      async function initializeSession() {
        // Ensure we only load the model once
        session = await ort.InferenceSession.create('http://kemmerling.me/guitarid_model_v0.0.1.onnx');
        console.log('Session initialized:', session);

      }

      // Ensure session is loaded when page starts
      initializeSession();

      // Function to handle the image upload
      function handleImageUpload(event) {
        const file = event.target.files[0];
        if (file) {
          const reader = new FileReader();
          reader.onload = function(e) {
            const img = new Image();
            img.src = e.target.result;
            img.onload = function() {
              // Reset and display the new image
              document.getElementById('upload-container').innerHTML = '';
              document.getElementById('upload-container').appendChild(img);

              // Prepare the image for the ONNX model (resize, preprocess, etc.)
              preprocessImage(img).then((inputTensor) => {
                // Run the ONNX model with the processed input
                runModel(inputTensor);
              });
            };
          };
          reader.readAsDataURL(file); // Trigger FileReader to read the new image
        }
      }

      // Function to preprocess the image before passing it to the ONNX model
      async function preprocessImage(img) {
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        const width = 224; // Example target size for model input
        const height = 224;

        // Resize the image to the model's input size
        canvas.width = width;
        canvas.height = height;

        // Clear canvas before drawing a new image (to avoid stale data)
        context.clearRect(0, 0, width, height);

        // Draw new image onto the canvas
        context.drawImage(img, 0, 0, width, height);

        // Get image data from the canvas
        const imageData = context.getImageData(0, 0, width, height);
        const { data } = imageData;

        // Normalize pixel values according to the mean and std for each channel
        const mean = [0.485, 0.456, 0.406];
        const std = [0.229, 0.224, 0.225];

        const input = new Float32Array(data.length / 4 * 3); // For 3 channels (RGB)
        for (let i = 0, j = 0; i < data.length; i += 4, j += 3) {
          // Normalize the RGB values
          input[j] = (data[i] / 255.0 - mean[0]) / std[0];     // R
          input[j + 1] = (data[i + 1] / 255.0 - mean[1]) / std[1]; // G
          input[j + 2] = (data[i + 2] / 255.0 - mean[2]) / std[2]; // B
        }

        // Return the preprocessed tensor
        const tensor = new ort.Tensor('float32', input, [1, 3, width, height]);
        console.log('Input tensor:', tensor); // Log each tensor to ensure it is new
        return tensor;
      }

      function argMax(array) {
        return array.map((x, i) => [x, i]).reduce((r, a) => (a[0] > r[0] ? a : r))[1];
      }
      // Function to run the ONNX model and output results
      async function runModel(inputTensor) {
        try {
          console.log('Running model with input tensor:');
          console.log(inputTensor);

          // Pass the input tensor as an array to the run function
          const feeds = {'input.1': inputTensor};
          const output = await session.run(feeds);
          console.log('Model output:', output);

          if (output.size === 0) {
            document.getElementById('output').textContent = 'Model did not return any output.';
            return;
          }

          // Retrieve the first output tensor
          const outputTensor = output[modelOutputName];
          console.log('Output tensor:', outputTensor);

          arr = outputTensor.data;
          index = arr.indexOf(Math.max(...arr));
          console.log(index);
          class_name = classNames[index];
          console.log(class_name);


          if (!outputTensor) {
            document.getElementById('output').textContent = 'Output tensor is undefined or null.';
            return;
          }

          // Display the output data
          document.getElementById('output').textContent = `Model Output: ${class_name} (${outputTensor.data})`;
        } catch (error) {
          console.error("Error running the model:", error);
          document.getElementById('output').textContent = 'Error running the model. Check the console for details.';
        }
      }
    </script>
  </body>
</html>
